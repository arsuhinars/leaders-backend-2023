# Сервис автоматического распределения задач для выездных сотрудников банка

# Производственное решение

Вертикально и горизонтально масштабируемый сервис. Сервис разделяется на frontend, распределитель нагрузки,
backend, db. Можно размножать количество backend серверов. Ознакомиться со схемой производственного решения:

`production_solution.yaml`

# База данных

Сервис использует СУБД PostgreSQL. Ознакомиться со схемой баз данных:

`db_schema.drawio`

База данных разделяется на несколько таблиц: 

account, employee, agent_point, task, task_status, task_manual

account. Таблица с данными об аккаунтах пользователей. Содержит логин, пароль, ФИО и роль. Пароль хранится в БД в виде хэша.
Методы сервиса не возвращают пароль-хеш.

employee. Таблица с данными о сотрудниках. Содержит грейд сотрудника и адрес начала работы.

agent_point. Таблица с агентскими точками. Содержит адрес точки, время подключения, доставлены ли материалы,
Кол-во дней после выдачи последней карты, Кол-во одобренных заявок, Кол-во выданных карт

task. Таблица с задачами. Содержит тип задачи, дату выполнения, начало времени выполнения, 
сколько часов занимает задача, дистанция до задачи от работника, номер в очереди по счету сегодняшних задач

task_status. Таблица со статусом задачи. Содержит выполнена ли задача, комментарий. 
Сотрудник может ставить статус задаче и оставлять комментарии по мере выполнения задачи.

task_manual. Таблица с типом задачи и условиями задачи. Содержит приоритет, время выполнения,
требуемый уровень сотрудника. В зависимости от типа задачи содержит разные условия. Хранятся условия в
виде json. Поле в базе данных представляет собой абстрактный класс BaseTaskManual, 
который могут унаследовать разные задачи. Условия в зависимости от сохраняемого класса (типа задачи):

Для задачи выезда на точку для стимулирования выдач: число в первом условии и число во втором условии.

Для задачи обучения агента: число, которое выражает процент; второе число.

Для задачи доставки карт и материалов: время подключения.

# API схема
Схема api доступна:

`api_schema.yaml`

В некоторых методах добавлена возможность пагинации.
Методы разделены правами доступа на Админа, менеджера и сотрудника.
Методы защищены http basic authentication.

Всего 5 заголовков, которые соответствуют названиям таблиц в БД:
Accounts, Agent points, Task manual, Employees, Tasks.

Accounts. В методах нельзя получить пароль.

Task manual. Методы для разных задач разделены разными url путями.




Можно динамически указывать порты, настройки БД, токен к graphhoper geocoding в файле:

`.env`


## Get Started


## Installation

### Docker

# Technical Overview

## OpenStreetMap Support

OpenStreetMap is directly supported by GraphHopper. Without the amazing data from
OpenStreetMap, GraphHopper wouldn't be possible at all.
Other map data will need a custom import procedure, see e.g. <a href="https://github.com/graphhopper/graphhopper/issues/277">Ordnance Survey</a>,
<a href="https://github.com/graphhopper/graphhopper-reader-shp">Shapefile like ESRI</a> or <a href="https://github.com/OPTITOOL/morituri">Navteq</a>.

## Written in Java

## Customizable

api token graphhopper используется только для геокодинга. Построением маршрутов занимается подтянутый с
помощью pom.xml open source, установленный локально движок graphhopper.


## Запуск
1) Скачиваем файл `south-fed-district-latest.osm.pbf` с сайта https://download.geofabrik.de/russia/south-fed-district.html
   И кладем в папку resources по адресу "src/main/resources/south-fed-district-latest.osm.pbf"
Примечание: для работы приложения по всей России, нужно скачать карту всей России.  
Можно также ограничиться нужным вам регионом.
## Запуск с traefik
1) распаковываем контейнеры на разных машинах: frontend, apiLoadBalancer, api1, api2, ..., apin, db.  
    Количество frontend серверов тоже можно размножить  
    1 контейнер - 1 машина.  
    Архитектуру production решения можно изменять в зависимости от ситуации 
2) указываем нужные ip

Для тестирования можно оставить монолит
Для тестирования можно использовать комманду:  
   docker compose -f docker-compose.example-api.yaml up -d --scale whoami=3 

traefik слушает все ip, у которых порт 80 и транслирует на 80 порту
api соединяется с traefik с помощью hostname. В данном случае 127.0.0.1. 
Может быть указан зарегестрированный официальный домен или локальный домен
в качестве hostname.
В api наружу выставляется рандомный ip и порт 80.
В примере 127.0.0.1:80 (traefik) -> x.x.x.x:80 (api instance x),  
x - целое число

      # для запуска на монолите удобно использовать строку ниже
      # - "traefik.http.routers.whoami.rule=Host(`api.localhost`)"
      # тогда запрос к api через traefik будет api.localhost:80